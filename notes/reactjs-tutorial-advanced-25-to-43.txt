REACTJS TUTORIAL (ADVANCED) #25 to #43

# 25 - Fragments.
    Fragments allows you to group a list of children to the DOM without wrapping them with a parent node or component.
    With fragments, we can wrap a group of children components or JSX, so that they are rendered without a parent.
    Syntax:
        >>> <React.Fragment>
                <h1>Hello, world!</h1>
                <SomeComponent />
                <div>We are all rendered without a parent</div>
            </React.Fragment>
    Fragments also accept a unique "key" prop which is useful when rendering list items, but you do not want to wrap
    the content of the UI JSX.
    Example:
        >>> const items = [...];   // some list of items
            const itemList = items.map(item => (
                <React.Fragment key={item.id}>
                    <h1>{item.title}</h1>
                    <p>{item.content}</p>
                </React.Fragment>
            ));
    A shorter syntax to <React.Fragment> is an empty tag: <> showing that the child components or JSX are not wrapped
    by a parent component or JSX. This shorter syntax, however, does not accept the unique "key" props.

# 26 - Pure Components.
    Pure components are class components which extend the `PureComponent` from React. While a regular component does not
    implement the `shouldComponentUpdate` method (thus, returning `true` by default), a Pure component implements the
    `shouldComponentUpdate` method with a shallow `props` and `state` comparison. By shallow comparison (SC), the
    previous props (or state) and the current props (or state) are compared and true is returned when:
        - both values are the same value and are of the same type (for primitive types e.g. strings, booleans, etc.); or
        - both values reference (points to) the same object (for complex types e.g. arrays, objects, etc.).
    Thus, a pure component only re-renders if and only if, there is a change in `props` or `state` determined by a
    shallow comparison of the previous props (or state) and the current props (or state). Emphasis is made on the fact
    that the comparison is "shallow", since if a `prop` of complex type (array, object, etc.) is modified (e.g. by
    pushing to the array, or adding new property to the object), the reference to the object is not changed and the
    `prop` is not considered to be any different, and the UI is not re-rendered. It is therefore, advised to always
    return or set the state to a new object or array (for complex types) instead of mutating (i.e. modifying) it.
    Tip: While Pure components seem to be very useful, it is safe to stick to the regular component and only use them in
    scenarios where optimisation can be achieved by preventing unnecessary re-rendering.
    Also, it is also very important to ensure that a component being pure does not prevent the child component from
    re-rendering when necessary since if the parent component does not re-render, the child component will not re-render
    even if it needs to. Ideally, the child components should be pure if the parent component is also pure. This helps
    to avoid unexpected behaviour.

# 27 - memo
    React.memo() (shorted as "memo") allows us to achieve the equivalent functionality of pure component for functional
    component. It prevents a functional component from re-rendering if the `props` has not changed since the last time.
    This is done by export the return value of React.memo(SomeComponent) instead of just the `SomeComponent`.
    Syntax:
        >>> export default React.memo(SomeComponent);
    Tip: React.memo, here, is a "higher order component" or HOC - components which accept other components are arguments
    and add a functionality to them.

# 28 - Refs.
    Refs makes it possible to access DOM nodes directly from a React. They provide a 'reference' to an HTML DOM element
    in a React component.
    To create a reference to a DOM node:
        - create the 'ref' using React.createRef() method (usually in the constructor) assigned as a class property.
            >>> this.refName = React.createRef();
        - next, attach the ref created using the reserved "ref" prop in the HTML or JSX element setting it to the 'ref'.
            >>> <input ref={this.refName} />
        - you can then access the value any time using `this.refName.current`
            >>> const inputEl = this.refName.current;
    Another (a bit older) method of creating refs is using the "callback ref" approach:
        - create a property to hold the "ref" (usually in the constructor).
            >>> this.refEl = null;
        - create a callback that sets the ref; the callback should accept one parameter - the DOM element to be
        referenced - and then perform certain actions usually assigning it to the property holding the "ref".
            >>> this.setCallbackRef = (element) => {
                this.refEl = element;
            }
        - attach the callback reference to the element using the reserved "ref" props.
            >>> <input type="text" ref={this.setCallbackRef} />
        - you can now access the "ref" via `this.refEl`. It is important to check the value before proceeding with the
        value of `this.refEl` as it could be null, if not set or if the component is unmounted.
            >>> if (this.refEl) {
                // perform some actions
                const inputEl = this.refEl;
            }

# 29 - Refs with Class Components
    Apart from native HTML DOM elements, you can also attach "refs" to custom React component in the same manner as you
    attach "refs" to the native HTML element using the reserved "ref" prop.
    Syntax:
        >>> <CustomInput type="text" ref={this.myInputRef} />
    Having access to a reference of <CustomInput/> allows us to call its methods, or perform other actions.
    NB: Creating refs in this way can only be done in class components.

# 30 - Forwarding Refs.
    Ref forwarding is a technique used to pass down "refs" automatically to a component to one of its children.
    Example:
        >>> const SomeComponent = React.forwardRef((props, ref) => (
            <div>
                <h1>{pros.title}</h1>
                <p>{props.text}</p>
                <button ref={ref}></button>
            </di>
        ));
    In this example, any reference to the `SomeComponent` component in a parent component is forwarded straight
    to the <button> HTML DOM element. The parent component may have some "ref" to it as:
    Example:
        >>> <SomeComponent ref={this.btnRef} />
    That is, although the "ref" is attached to the `SomeComponent`, it is being forwarded to the <button> element.

# 31 - Portals
    React Portals provides a way to render children elements into a node that exists outside the DOM hierarchy.
    Usually, JSX are rendered as they are - children components are rendered as children elements, in such a way that
    any child component must be equally be rendered as HTML child elements in the DOM. With portals, we can render a
    child component as a child element of a different node. This is done when returning the JSX to be rendered using the
    ReactDOM.createPortal() method from ReactDOM imported from "react". It takes at least two arguments: the JSX to be
    rendered, and the node to render the JSX.
    Example:
        >>> return ReactDOM.createPortal(<h1>Hello, world1</h1>, document.getElementById("portal-root"));
    Portals are useful in scenarios where the parent component (HTML element or node) affects the rendering of the child
    (usually in styling e.g. in modals which may need to cover the full screen while their parents have limited
    width/height).
    Additionally, although portals exists outside their parent component hierarchy, the event propagation bubbles up to
    the parent component as if they are DOM children to their parents. That is, even if an element is rendered in a
    different DOM node (via portals), when it fires an event (e.g. when clicked), this event is propagated to the parent
    component going up to the ancestors in the DOM tree (rather than the actual DOM node where it is rendered in). Thus,
    a "click" event, for example, can be handled by the parent component, even though it is not rendered under it in
    the DOM tree. This makes them seem as if they are part of the same DOM tree.

# 32 - Error Boundary
    An Error Boundary is a class component that implements either one or both of the error handling lifecycle methods:
    `static getDerivedStateFromError` or `componentDidCatch`.
    The static method `getDerivedStateFromError` method is used to render a fallback UI after an error is thrown and the
    `componentDidCatch` method is used to log the error information.
    The function of Error boundaries is to catch JavaScript error in the child component tree, log those errors and
    display a fall-back UI. This is done by wrapping the component(s) with the Error boundary component.

# 33 - Higher Order Components (Part 1)
    Higher Order Components are components which accept other components as arguments. They allow developers to share
    common functionality amongst components. For illustration, consider a situation where we wish to build three or more
    counter components which increment the internal state "count" variable when a particular event is fired (e.g. when
    clicked for one, hovered for the other, when selected or when a key is pressed in an input). Since we do not want to
    duplicate the common functionality which is "incrementing the count variables" we can devise other means to share
    this functionality. One option is to lift the "increment count" logic to a parent component, pass the function as a
    prop, allowing each component to pass its instance (via the `this` keyword) so that its state (i.e. the "count"
    variable) is updated. This solution, however ties the individual counter to the parent components and is not ideal
    in situations in which we don't always want the individual counter component to be a direct child to the parent
    counter component holding the logic.
    In this situation, HOCs can be used to include the functionality to any component which is passed down to it as
    argument, returning a new "enhanced" form of that component (with the "counter logic" functionality).

# 34 - Higher Order Components (Part 2)
    Definition: Higher Order Component (shortened as "HOC") is a pattern where a function takes a component as an
    argument and returns a new component.
    Syntax:
        >>> const EnhancedComponent = HigherOrderComponent(OriginalComponent);
    Typically, they add a particular functionality or logic to a component, thus, "enhancing" their functionality.
    Below, is a typical HOC:
        >>> const withFunctionality = (WrappedComponent) => {
            class WithFunctionality extends React.Component {
                constructor(props) {
                    super(props);

                    this.state = {
                        someStateVariable: null
                    }
                }

                someSharedFunctionality = () => {
                    // modify `someStateVariable` here
                    // do other things
                    // ...
                }

                render() {
                    return <WrappedComponent
                        stateVar={this.someStateVariable}
                        someFunctionality={this.someSharedFunctionality}
                    />
                }
            }

            return WithFunctionality;
        }
    Usage:
        >>> export default withFunctionality(SomeComponent);
            export default withFunctionality(SomeOtherComponent);

    Here `withFunctionality` is the HOC which adds `someSharedFunctionality` to the wrapped components which are
    being exported.

# 35 - Higher Order Components (Part 3)
    Two more points to note about Higher Order Components (HOCs) are:
        - when props are passed down to a component wrapped by an HOC, the props is being passed to the HOC and not to
        the component itself. Consider the example:
            >>> <SomeComponent greeting="Bonjour" />
        Here, the `greeting` props is not cannot be accessed via `this.props.greeting` in the `SomeComponent`
        component (say in SomeComponent.js file), rather it is accessible in the HOC (say withFunctionality.js file).
        To access props passed to an "enhanced" component in the actual/original component, you have to pass down the
        `prop` from the HOC down to the component. It is common to pass down all props once and for all in the HOC
        to the component using the spread operator (...) - as in {...this.props}.
        Example: In the HOC's render() method:
            >>> return (
                <WrappedComponent
                    stateVar={this.someStateVariable}
                    someFunctionality={this.someSharedFunctionality}
                    {...this.props}
                />
        - lastly, you can also pass down extra arguments (or parameters) when passing the component to be enhanced.
        Example:
            >>> export default withFunctionality(SomeComponent, 3);
        Here, the HOC `withFunctionality` accepts an extra parameter. The HOC definition may be as follows:
            >>> const withFunctionality = (WrappedComponent, someParameter) => {
                // ...
            }

# 36 - Render Props (Part 1)
    Render Props is another technique to share common functionality among different components.
    We shall see how to make use of the concept of "Render Props" to share common functionality in the next lesson.

# 37 - Render Props (Part 2)
    The term "render prop" refers to a technique for sharing code between React components using a prop whose value is a
    function. The idea behind this is that:
        - a component is created which holds the functionality that needs to be shared.
        - this component will have a `prop` conventionally, the "render" prop is used.
        - the value of this prop will be a function which accepts the `state` and the common functionality (usually a
        function) to be shared, and the function returns the individual component which requires the functionality with
        the `state` and the common functionality passed to the component via `props`.
        - the component holding the functionality now renders the component via its `render` prop, hence the name
        "render" prop.
        NB: In a slightly different approach, the `render` prop is not used explicitly but the individual component
        requiring the functional is wrapped and returned by a function as if the function were a child to the component
        holding the functionality i.e. the individual component which needs a functionality is wrapped by a function
        which returns it and can be rendered by the "parent" component via `this.props.children`.
        Syntax:
            >>> <SomeFunctionalityComponent
                render={ (state, functionality) => (
                    <IndividualComponent state={state} someFunctionality={functionality} />
                ) }
            />
            <SomeFunctionalityComponent
                render={ (state, functionality) => (
                    <AnotherIndividualComponent state={state} someFunctionality={functionality} />
                ) }
            />

            // OR ... (using the `children` prop approach instead)
            <SomeFunctionalityComponent
                (state, functionality)  => {
                    <IndividualComponent state={state} someFunctionality={functionality} />
                }
            />

            // In the SomeFunctionalityComponent render method (possibly, SomeFunctionalityComponent.js file)
            >>> return (
                <div>
                    this.props.render(state, functionality)
                </div>
            )
    Tip: In the "render prop" pattern, the state as well as the functionality is owned, maintained and managed by the
    `SomeFunctionalityComponent` (the component holding the functionality to be shared) - just like in the HOC pattern.
    However, since a different instance is used for each individual component, the state is not conflicted, although
    they share the same functionality.


