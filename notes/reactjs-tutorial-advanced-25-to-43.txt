REACTJS TUTORIAL (ADVANCED) #25 to #43

# 25 - Fragments.
    Fragments allows you to group a list of children to the DOM without wrapping them with a parent node or component.
    With fragments, we can wrap a group of children components or JSX, so that they are rendered without a parent.
    Syntax:
        >>> <React.Fragment>
                <h1>Hello, world!</h1>
                <SomeComponent />
                <div>We are all rendered without a parent</div>
            </React.Fragment>
    Fragments also accept a unique "key" prop which is useful when rendering list items, but you do not want to wrap
    the content of the UI JSX.
    Example:
        >>> const items = [...];   // some list of items
            const itemList = items.map(item => (
                <React.Fragment key={item.id}>
                    <h1>{item.title}</h1>
                    <p>{item.content}</p>
                </React.Fragment>
            ));
    A shorter syntax to <React.Fragment> is an empty tag: <> showing that the child components or JSX are not wrapped
    by a parent component or JSX. This shorter syntax, however, does not accept the unique "key" props.

# 26 - Pure Components.
    Pure components are class components which extend the `PureComponent` from React. While a regular component does not
    implement the `shouldComponentUpdate` method (thus, returning `true` by default), a Pure component implements the
    `shouldComponentUpdate` method with a shallow `props` and `state` comparison. By shallow comparison (SC), the
    previous props (or state) and the current props (or state) are compared and true is returned when:
        - both values are the same value and are of the same type (for primitive types e.g. strings, booleans, etc.); or
        - both values reference (points to) the same object (for complex types e.g. arrays, objects, etc.).
    Thus, a pure component only re-renders if and only if, there is a change in `props` or `state` determined by a
    shallow comparison of the previous props (or state) and the current props (or state). Emphasis is made on the fact
    that the comparison is "shallow", since if a `prop` of complex type (array, object, etc.) is modified (e.g. by
    pushing to the array, or adding new property to the object), the reference to the object is not changed and the
    `prop` is not considered to be any different, and the UI is not re-rendered. It is therefore, advised to always
    return or set the state to a new object or array (for complex types) instead of mutating (i.e. modifying) it.
    Tip: While Pure components seem to be very useful, it is safe to stick to the regular component and only use them in
    scenarios where optimisation can be achieved by preventing unnecessary re-rendering.
    Also, it is also very important to ensure that a component being pure does not prevent the child component from
    re-rendering when necessary since if the parent component does not re-render, the child component will not re-render
    even if it needs to. Ideally, the child components should be pure if the parent component is also pure. This helps
    to avoid unexpected behaviour.

# 27 - memo
    React.memo() (shorted as "memo") allows us to achieve the equivalent functionality of pure component for functional
    component. It prevents a functional component from re-rendering if the `props` has not changed since the last time.
    This is done by export the return value of React.memo(SomeComponent) instead of just the `SomeComponent`.
    Syntax:
        >>> export default React.memo(SomeComponent);
    Tip: React.memo, here, is a "higher order component" or HOC - components which accept other components are arguments
    and add a functionality to them.

# 28 - Refs.
    Refs makes it possible to access DOM nodes directly from a React. They provide a 'reference' to an HTML DOM element
    in a React component.
    To create a reference to a DOM node:
        - create the 'ref' using React.createRef() method (usually in the constructor) assigned as a class property.
            >>> this.refName = React.createRef();
        - next, attach the ref created using the reserved "ref" prop in the HTML or JSX element setting it to the 'ref'.
            >>> <input ref={this.refName} />
        - you can then access the value any time using `this.refName.current`
            >>> const inputEl = this.refName.current;
    Another (a bit older) method of creating refs is using the "callback ref" approach:
        - create a property to hold the "ref" (usually in the constructor).
            >>> this.refEl = null;
        - create a callback that sets the ref; the callback should accept one parameter - the DOM element to be
        referenced - and then perform certain actions usually assigning it to the property holding the "ref".
            >>> this.setCallbackRef = (element) => {
                this.refEl = element;
            }
        - attach the callback reference to the element using the reserved "ref" props.
            >>> <input type="text" ref={this.setCallbackRef} />
        - you can now access the "ref" via `this.refEl`. It is important to check the value before proceeding with the
        value of `this.refEl` as it could be null, if not set or if the component is unmounted.
            >>> if (this.refEl) {
                // perform some actions
                const inputEl = this.refEl;
            }

# 29 - Refs with Class Components
    Apart from native HTML DOM elements, you can also attach "refs" to custom React component in the same manner as you
    attach "refs" to the native HTML element using the reserved "ref" prop.
    Syntax:
        >>> <CustomInput type="text" ref={this.myInputRef} />
    Having access to a reference of <CustomInput/> allows us to call its methods, or perform other actions.
    NB: Creating refs in this way can only be done in class components.

# 30 - Forwarding Refs.
    Ref forwarding is a technique used to pass down "refs" automatically to a component to one of its children.
    Example:
        >>> const SomeComponent = React.forwardRef((props, ref) => (
            <div>
                <h1>{pros.title}</h1>
                <p>{props.text}</p>
                <button ref={ref}></button>
            </di>
        ));
    In this example, any reference to the `SomeComponent` component in a parent component is forwarded straight
    to the <button> HTML DOM element. The parent component may have some "ref" to it as:
    Example:
        >>> <SomeComponent ref={this.btnRef} />
    That is, although the "ref" is attached to the `SomeComponent`, it is being forwarded to the <button> element.

# 31 - Portals
    React Portals provides a way to render children elements into a node that exists outside the DOM hierarchy.
    Usually, JSX are rendered as they are - children components are rendered as children elements, in such a way that
    any child component must be equally be rendered as HTML child elements in the DOM. With portals, we can render a
    child component as a child element of a different node. This is done when returning the JSX to be rendered using the
    ReactDOM.createPortal() method from ReactDOM imported from "react". It takes at least two arguments: the JSX to be
    rendered, and the node to render the JSX.
    Example:
        >>> return ReactDOM.createPortal(<h1>Hello, world1</h1>, document.getElementById("portal-root"));
    Portals are useful in scenarios where the parent component (HTML element or node) affects the rendering of the child
    (usually in styling e.g. in modals which may need to cover the full screen while their parents have limited
    width/height).
    Additionally, although portals exists outside their parent component hierarchy, the event propagation bubbles up to
    the parent component as if they are DOM children to their parents. That is, even if an element is rendered in a
    different DOM node (via portals), when it fires an event (e.g. when clicked), this event is propagated to the parent
    component going up to the ancestors in the DOM tree (rather than the actual DOM node where it is rendered in). Thus,
    a "click" event, for example, can be handled by the parent component, even though it is not rendered under it in
    the DOM tree. This makes them seem as if they are part of the same DOM tree.

