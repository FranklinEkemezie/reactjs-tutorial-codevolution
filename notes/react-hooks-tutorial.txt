REACT HOOKS TUTORIAL

# 1 - Introduction
    Prerequisites - Basics of React, functional and class components, props, state, etc.
    What are Hooks - Hooks are a new feature addition in React version 16.8 which allow you to use React features
    without having to write a class. With hooks, we can create functional components which can manage their own
    states, and also be able to "hook" into other React features.
    Why Hooks?
        - Avoid the use of `this` keyword - thus, preventing the pain in understanding how the `this` keyword works; you
        don't also need to bind event handlers; and classes in general do not minify very well, and make hot reloading
        unreliable.
        - Provides a way to reuse stateful component logic since HOC and render props pattern, while they are useful
        often forces one to restructure the code, making it harder to read.
        - Using lifecycle methods leads to grouping unrelated codes in one block of code, while related ones are
        scattered in different lifecycle methods, making complex class components become unreadable. Hooks allow you to
        group related in smaller functions, thus components can efficiently be broken to even smaller ones, when needed.
    Note that: React Hooks
        - are available in React version 16.8 or higher.
        - are completely opt in and backward compatible (no breaking changes).
        - do not work inside a class component.
        - provide a more direct API to the React concepts you already know - state, context, refs, effects, etc. Hence,
        the introduction of hooks do not replace your existing knowledge of various React concepts.
        - can be used along with class components in a React applications. Classes won't be removed from React anytime
        soon.

# 2 - useState Hook
    The first hook we'll talk about is the `useState` hook which allows us to create and manage state within functional
    components. The `useState` hook is function which accepts the initial state value amd returns an array which has
    two elements, the first is the state value and the second is a function to update the state.
        >>> const [count, setCount] = useState(0);
    It is a common convention to use array destructing to set the state variable value and the state update function.
    The naming pattern/convention widely used is `varName` for the state variable and `setVarName` for the state update
    function.
    To update the state value, the new value is passed to the state update function as argument, as in:
        >>> setCount(count + 1);
    How does it work:
        - When the component is created, the state variable is set to the value passed into `setCount()`.
        - When the state is changed (or updated), the component re-renders.
        - On re-rendering, count now takes on the new (i.e. updated) value.

    Rules of Hooks: General rules to consider when making use of any hook are:
        - Only call hooks at the top level - don't call them inside loops, conditions, or nested functions.
        - Only call hooks from React functions - and not just any regular JS function.

# 3 - useState with previous state
    A slightly different version of the state update function returned by `useState()` accepts a function argument
    instead of the updated value of the state variable. This function returns the new state value. This version should
    bse used when the new state value of a state variable depends on its previous state e.g. negating the (boolean) state value,
    or increasing count. This is because, the state update function batches multiple calls into one to enhance
    performance and may lead to UI bugs (since the state does not update as many times as it should). Passing in a
    function which returns the new state is a good approach to always ensure that the previous state is always updated
    before it is used in the next update function call.
    Syntax:
        >>> setCount(() => count + 1);

# 4 - useState with object
    Since the setter (state update) function provided by `useState()` hook overwrites the previous state value to the
    new one, the previous object is not merged with/included in the new object when the state value is an object. The
    spread operator (...) is therefore used to include the previous properties along with the newly updated one.
    For example:
        >>> const [name, setName] = useState({firstName: '', lastName: ''});
        >>> setName({firstName: 'Hello'});
            // now name becomes {firstName: 'Hello'} leaving out the `lastName` property, use this syntax instead:
            setName({...name, firstName: 'Hello'});

# 5 - useState with array
    Similarly, when an array is used as a state value, the new value added to the array is not merged/appended to the
    previous state value (array). The spread operator should be used to include the previous items before adding the new
    items.
    >>> Syntax:
        setItems([...items, newItem]);

# 6 - useEffect Hook.
        useEffect hook allows us to cause side effects without using lifecycle methods in class components. In class
    components, the lifecycle methods provide a way to "hook" into the lifecycle of the component and perform certain
    actions, as at when due. The `componentDidMount()`, `componentDidUpdate()` and `componentWillUnmount()` are suitable
    and common places to place codes which may cause side effects e.g. interacting with the DOM, or making HTTP requests.
    However, it leads to grouping unrelated codes together, just for the only reason that we want them to run when the
    component is mounted or updated. Also, if we wish to perform an action when the component is mounted and also when
    it is updated, we'd have to write (split) them in separate code blocks.
        The `useEffect` hook provides a way to cause side effects while allowing related codes to be grouped together as
    well as avoid repeating the same block of codes, hence resulting in more organised and readable code. It is
    therefore, a close (all-in-one) replacement for the `componentDidMount`, `componentDidUpdate` and
    `componentWillUnMount` lifecycle methods.

# 7 - useEffect after render
    The `useEffect` hook, like `useState` is JS function. It accepts a function as an argument - the function being the
    effect you want to make. The function contains the code you want to execute after every render (whether initial
    render or subsequent (or re-) renders).
        >>> Syntax:
            useEffect(() => {
                // effect goes here...
            });
    Since the `useEffect` is used directly in the component, you can access the props or state directly without writing
    additional code. In the coming lessons, we'll explore how we can customise the useEffect hook to only execute our
    effect when we need it to do so instead of after every render.

# 8 - Conditionally run effects
    We can run effects conditionally usually when a props or state has changed so far. To do this, useEffect provides a
    second parameter - a dependency array - the array should contain a list of props, or state variable which the
    useEffect hook should watch out for, and run the effects only when any of these items in the dependency array has
    changed.
        >>> Syntax:
            useEffect(() => {
                // code to run only when any of the dependencies changes...
            }, [dep1, dep2, dep3]);

# 9 - Run effects only once
    Much like in `componentDidMount()` lifecycle method, we may wish to run an effect only once e.g. adding event
    listeners. To replicate this in the `useEffect` hook, an empty array is passed as the dependency parameter. This
    effectively instructs React to run the effect only once on initial render.
        >>> Syntax:
            useEffect(() => {
                // code to run only once...
            }, []);

